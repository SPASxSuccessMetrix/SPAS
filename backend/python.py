# -*- coding: utf-8 -*-
"""mongodb<-> python connection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lRnfzlq5czPN0JvlMErF170PHjI3PPUZ
"""

#install and import libraries
# pip install pymongo
import pandas as pd
import pymongo
from pymongo import MongoClient
import json
import csv
# pip install matplotlib seaborn bokeh
import numpy as np
import tensorflow as ts
from tensorflow import keras
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import seaborn as sns
from bokeh.plotting import figure, show
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import StandardScaler
from sklearn.multioutput import MultiOutputClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.datasets import make_multilabel_classification
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
from sklearn.multioutput import ClassifierChain
from numpy import mean
from numpy import std
from sklearn.model_selection import RepeatedKFold
from keras.models import Sequential
from keras.layers import Dense
from tensorflow.keras.models import load_model
import sys


sys.stdout.reconfigure(encoding='utf-8')

def mongo_to_dataframe(client_uri: str, database_name: str, collection_name: str) -> pd.DataFrame:
  """
  Converts documents from a MongoDB collection to a pandas DataFrame.

  Args:
      client_uri (str): MongoDB connection URI.
      database_name (str): Name of the database containing the collection.
      collection_name (str): Name of the MongoDB collection to export.

  Returns:
      A pandas DataFrame containing the collection data.
  """

  try:
    # Connect to MongoDB
    cluster = MongoClient(client_uri)
    db = cluster[database_name]
    collections = db[collection_name]

    # Validate collection existence (optional)
    if not collections.count_documents({}):
      print(f"Collection '{collection_name}' is empty or doesn't exist.")
      return pd.DataFrame()

    # Get all documents as a list of dictionaries
    data = list(collections.find())

    # Create a DataFrame from the list
    df = pd.DataFrame(data)

    return df

  except Exception as e:
    print(f"An error occurred: {e}")
    return pd.DataFrame()

# Example usage (replace with your credentials)
client_uri = "mongodb+srv://gagandeep9603:SPAS123@cluster0.3qiut2o.mongodb.net/"
database_name = "spas"
collection_name = "users"

df = mongo_to_dataframe(client_uri, database_name, collection_name)

if not df.empty:
  print()
  #print(df)
  # You can now use the DataFrame 'df' for further analysis
else:
  print("No data found in the collection.")

def get_df():
  client_uri = "mongodb+srv://gagandeep9603:SPAS123@cluster0.3qiut2o.mongodb.net/"
  database_name = "spas"
  collection_name = "users"
  output_filename = "test.csv"
  return mongo_to_dataframe(client_uri, database_name, collection_name)

def preprocess_df(df):
  """
  Preprocesses a DataFrame containing survey responses for learning style analysis.

  Args:
      df: The pandas DataFrame containing the survey data.

  Returns:
      A preprocessed DataFrame with additional columns for OCEAN scores and dropped unnecessary columns.
  """

  # Add empty columns for independent and dependent features
  df = pd.concat([df, pd.DataFrame({"O": [], "C": [], "E": [], "A": [], "N": []})], axis=0)  # Independent features
  df = pd.concat([df, pd.DataFrame({"AE": [], "CE": [], "RO": [], "AC": []})], axis=0)  # Dependent features

  # Fill missing values with 0
  df = df.fillna(0)

  # Add OCEAN scores
  df["O"] = df["How often do you think you participate in classroom activities?"] + df["How often do you try to speak up in class?"]
  df["C"] = df["How comfortable are you expressing disapproval or criticising the work or behaviour of your classmates, even if you believe it's necessary?"] + df["How comfortable are you working in a team, where you might not necessarily be the leader?"]
  df["E"] = df["How often do you get distracted during a live class / while performing an academic task with a due date?"] + df["Do you prefer ordered and organized notes?"]
  df["A"] = df["How often do you find yourself irritated due to peers?"] + df["Do you often feel demotivated during academic work?"]
  df["N"] = df["What would you rate your creative skill (if no then rate 0) on a scale of 1 - 10"] +df["How often do you use methods that differ from traditional methods to solve a particular problem?"]

  for index, row in df.iterrows():
    for col in df.columns:
      value = row[col]
      if value in ["I like to see how I feel about it first", "I just trust my hunches and feelings", "I have feelings and reactions", "Feeling", "I get involved"]:
        df.at[index, 'CE'] += 1
      elif value in ["I like to just start, do it", "I work hard to get things done", "I am usually the one responsible", "Doing", "I am active"]:
        df.at[index, 'AE'] += 1
      elif value in ["I like to think about why", "I rely on logical thinking", "I tend to reason things out first", "Thinking", "I evaluate things"]:
        df.at[index, 'AC'] += 1
      elif value in ["I like to watch and listen before I do it", "I listen and watch carefully","I am quiet and reserved until comfortable", "Watching", "I observe"]:
       df.at[index, 'RO'] += 1

  #calculate learning style

  scores = [row['CE'], row['AE'], row['AC'], row['RO']]
  sorted_scores = sorted(scores, reverse=True)

  df['Learning Style'] = pd.NA

  for index, row in df.iterrows():
    max_score = sorted_scores[0]
    second_max_score = sorted_scores[0]

    if max_score == row['AE']:
      df.at[index, 'Learning Style'] = 'Diverging'
    elif max_score == row['CE']:
      df.at[index, 'Learning Style'] = 'Accommodating'
    elif max_score == row['AC']:
      df.at[index, 'Learning Style'] = 'Converging'
    elif max_score == row['RO']:
      df.at[index, 'Learning Style'] = 'Assimilating'

  learning_styles = ['Diverging', 'Accommodating', 'Converging','Assimilating']

  # Create new columns with 0s
  for style in learning_styles:
    df[f'{style}_Flag'] = 0

  # Fill 1s based on values in 'Learning Style'
  df['Diverging_Flag'] = df['Learning Style'].apply(lambda x: 1 if x == 'Diverging' else 0)
  df['Accommodating_Flag'] = df['Learning Style'].apply(lambda x: 1 if x == 'Accommodating' else 0)
  df['Converging_Flag'] = df['Learning Style'].apply(lambda x: 1 if x == 'Converging' else 0)
  df['Assimilating'] = df['Learning Style'].apply(lambda x: 1 if x == 'Assimilating' else 0)


  # Drop unnecessary columns
  df = df.drop(["_id","name","email","password","__v","role","Learning Style","Assimilating",
                "How often do you think you participate in classroom activities?",
                "How often do you try to speak up in class?",
                "How comfortable are you expressing disapproval or criticising the work or behaviour of your classmates, even if you believe it's necessary?",
                "How comfortable are you working in a team, where you might not necessarily be the leader?",
                "How often do you get distracted during a live class / while performing an academic task with a due date?",
                "Do you prefer ordered and organized notes?",
                "How often do you find yourself irritated due to peers?",
                "Do you often feel demotivated during academic work?",
                "What would you rate your creative skill (if no then rate 0) on a scale of 1 - 10",
                "How often do you use methods that differ from traditional methods to solve a particular problem?",
                "I learn best when"	,"I learn by",	"When I am learning", "When I learn", "When I need to learn"], axis=1)

  #encoding
  df["gender"] = df["gender"].str.lower()  # Convert all values to lowercase for case-insensitive comparison
  df["gender"] = df["gender"].replace({"male": 1, "female": 0}, regex=True)  # Replace with regex for partial matches
  df["gender"] = df["gender"].fillna(0)  # Fill NaN values with 0

  return df

from pymongo import MongoClient


def update_mongo_from_df(client_uri: str, database_name: str, collection_name: str, df: pd.DataFrame) -> None:
  """
  Updates a MongoDB collection with data from a pandas DataFrame.

  This function assumes the DataFrame's column names match the collection's document fields.

  Args:
      client_uri (str): MongoDB connection URI.
      database_name (str): Name of the database containing the collection.
      collection_name (str): Name of the MongoDB collection to update.
      df (pd.DataFrame): The pandas DataFrame containing data to insert.
  """

  try:
    # Connect to MongoDB
    cluster = MongoClient(client_uri)
    db = cluster[database_name]
    collection = db[collection_name]

    # Convert DataFrame to list of dictionaries (assuming each row represents a document)
    data = df.to_dict(orient='records')

    # Loop through data and insert documents
    for row in data:
      collection.insert_one(row)

    print(f"MongoDB collection '{collection_name}' updated from DataFrame!")

  except Exception as e:
    print(f"An error occurred: {e}")


# Example usage
# Assuming you have a DataFrame named 'dfresult'

df = get_df()
df = preprocess_df(df)

ml_df= df.iloc[:,1:7]
#enter ml model location here
model = load_model('multilabelmodel.h5')
prediction = model.predict(ml_df)

out_df = pd.DataFrame(prediction)
out_df = out_df.rename({
    0: 'Diverging_Flag',
    1: 'Accommodating_Flag',
    2: 'Converging_Flag',
    3: 'Assimilating_Flag'
}, axis = 1)
dfresult = pd.concat([df.iloc[:6,:], out_df],axis = 1)
collection_name = "ml_output"
update_mongo_from_df(client_uri, database_name, collection_name, dfresult)

